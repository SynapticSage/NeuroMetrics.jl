quickactivate("/home/ryoung/Projects/goal-code/")
@time include(scriptsdir("fields", "Initialize.jl"))

include(scriptsdir("timeshift", "TimeShift_setsOfInterest.jl"))

_, spikes = raw.register(beh, spikes; transfer=["velVec"], on="time")
import Base.Threads: @spawn
using ThreadSafeDicts
using .timeshift
using Combinatorics: powerset
sp = copy(spikes)
convertToMinutes = true

# ----------
# ----------
# ----------
# Parameters
# ----------
PROPS = ["x", "y", "currentHeadEgoAngle", "currentPathLength", "stopWell"]
IDEALSIZE = Dict(key => (key=="stopWell" ? 5 : 40) for key in PROPS)


#-------------------------------------------------------
"""
Translate into shorcut names
"""
𝕄(items)  = [replace(item, recon_process.var_shortcut_names...) 
             for item in items]
"""
UnTranslate from shorcut names
"""
𝕄̅(items)  = [replace(item, Dict(kv[2]=>kv[1] for kv in shortcut_names)...)
             for item in items]
sz(items) = [IDEALSIZE[item] for item in items]
#-------------------------------------------------------

splitby=["unit", "area"]
#gaussian=2.3*0.5
filts = filt.get_filters()
shifts = -4:0.2:4
shifts = convertToMinutes ? shifts./60 : shifts
function get_key(;shifts, kws...)
    (;kws..., first=first(shifts), last=last(shifts), step=Float64(shifts.step)) 
end

I = timeshift.load_mains();
S = timeshift.load_shuffles();
Kᵢ, Kₛ = keys(I), keys(S)

println(Panel(@blue("Kᵢ \n\n")*string(first(Kᵢ)); width=45) * 
        Panel(@blue("Kₛ \n\n")*string(first(Kₛ)); width=45))

I = Dict(remove_key_item(k, :shuf)=>I[k] for k in Kᵢ)
S = Dict(remove_key_item(k, :shuffle_type)=>S[k] for k in Kₛ)
Kᵢ, Kₛ = collect(keys(I)), collect(keys(S))
Kₛᵢ = [utils.pop(k, :shuffle_type) for k in  Kₛ]
K_shuf = Dict(ksi=>ks for (ksi, ks) in zip(Kₛᵢ,Kₛ))

common = intersect(Kᵢ, Kₛᵢ)
com = first(common)

for com ∈ common

    i, s = I[com], S[K_shuf[com]]

    i = timeshift.info_to_dataframe(i, shift_scale=:minutes)
    s = timeshift.info_to_dataframe(s, shift_scale=:minutes)
    ix = timeshift.imax(i)
    sx = timeshift.imax(s)

    i = groupby(i, :unit)
    s = groupby(s, :unit)
    ix = groupby(ix, :unit)
    sx = groupby(sx, :unit)

    mappingx = group.find_common_mapping(ix, sx)
    mapping = group.find_common_mapping(i, s)


    # Unified KEYMAP stuff goes here

end



